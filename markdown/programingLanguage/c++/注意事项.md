# c++注意事项

* ## double转化到int注意到事项

  * duoble到int的强制类型转换是通过向下(地板函数 floor)取整实现的，所以当一个duoble非常接近一个整数但又确实小于一个整数就会被舍入到这个整数减1(5.99999 -> 5)，这就可能带来较大的误差
  * (于此相类似取整函数还有"向上取整 天花板函数 ceil", "四舍五入 周围函数 round")
  * d -> double类型的变量(由整数赋值而来)
  * e -> double类型的误差(1E-6)
  * i -> int类型变量
    1. d + e -> i
       * d < 0: i = d+1
       * d >= 0: i = d
    2. d - e -> i
       * d > 0: i = d -1
       * d <= 0: i = d
  
* ## .h与.cpp文件的区别与联系

  * .h叫做头文件，它是不能被编译的。“#include”叫做编译预处理指令，可以简单理解成，在1.cpp中的#include"1.h"指令把1.h中的代码在编译前添加到了1.cpp的头部。每个.cpp文件会被编译，生成一个.obj文件，然后所有的.obj文件链接起来你的可执行程序就算生成了。
  * 模版函数或模版类一般不能分离式编译(即声明与定义在不同的文件中实现):
    * 在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。
      

















